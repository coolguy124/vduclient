\lstset{
language = {C++},
tabsize = 4,
captionpos=b,
showstringspaces=false,
numbers=left,
keywordstyle = \color{blue},
keywordstyle=[2]\color{gray},
stringstyle = \color[rgb]{0.64,0.08,0.08},
commentstyle = \color[rgb]{0,0.5,0},
numberstyle=\sffamily\tiny,
%morekeywords={WORD, DWORD, PWORD, PDWORD, LPWORD, LPDWORD, QWORD, PQWORD,
%INT, INT32, INT64, UINT, UINT32, UINT64, LONG, LONGLONG, SHORT,},
}

%==============================================================================================================================
\chapter{Introduction}
\label{ch1}

Nowadays, many services allow their users to have their essential documents saved and safely backed up somewhere in the \textit{cloud}. Be it photos, videos, or just some notes saved in a Word\footnote{\url{https://www.microsoft.com/en-ww/microsoft-365/word}} document, today's technology allows anyone to access their files from any device. For example, imagine a typical browser-based could service. All that is required is for the user to have an internet connection and login, prove their identity to the \textit{server}, and the application on the user's device, the \textit{client}, takes care of the rest. After successful authentication, the user's files are available to read, download, and upload. Manually, these actions can become quite a bit of an overhead as the file count increases. What if the number of users that have access increases as well? 

The answer is - controlled access to remote documents and version control, which should be present on the server's side. In this thesis's case, the basis is an internal, non-formal API description of such a server, which will be referred to as The Validated Data Storage project (VDU). As such, this thesis analyzes previously mentioned requirements of the API access and creates a client-side application for Microsoft Widnows\footnote{\url{https://www.microsoft.com/en-us/windows}} from the ground up. To allow for a better user experience, this thesis showcases an implementation of a virtual file system, present on a virtual disk, integrated right into the desktop environment of Windows. This type of integration means being able to seamlessly view and or modify a file stored in the cloud, as if it was present on a virtual disk, without the need to download or upload after each modification constantly manually. 

WinFsp\cite{WinFsp} allows for implementing a filesystem in the userspace for Windows and offers both lower and higher-level APIs to work with. As such, the implementation of the VDU client-side application (VDU Client) is programmed with C++. \todo{CONTINUE later}

\subsection*{Structure}
\todo{Add structure}

%==============================================================================================================================
\chapter{Development for Microsoft Windows}
\label{ch2}

With Windows consistently having more than a 70\% market share among operating systems across many years\cite{DesktopOSStats}, there is no need to overview it. This chapter introduces application development for Windows using the Windows API(also known as the Win32 API), the Microsoft Foundation Class Library, and provides an overview of these technologies. This information is relevant to implement the application in Chapter\ref{ch6}.

\section{Development Environment}
This section focuses on all the preliminaries related to setting up a development environment for Windows desktop development.

\subsection*{Microsoft Windows Software Development Kit}
The Microsoft Windows Software Development Kit (Windows SDK) is a required tool kit to develop and build applications for Windows. The Windows SDK contains all the libraries, headers, and tools required to design, implement, run, debug, and release Windows applications.

\subsection*{Operating System Version}
The operating system version, also referred to as the build number of Windows, is the application's target version, and it does not always match the operating system's name. Deciding which version to target is important because of the application's backward compatibility between operating systems.\cite{OsVersion} 

\begin{table}[hbt]
\centering
\caption{Desktop Windows Operating System Versions, released after 2006}
\label{osversions}
\begin{tabular}{|l|c|l|l|}
\hline
Operating System & Version \\ \hline
Windows 10       & 10.0    \\ \hline
Windows 8.1      & 6.3     \\ \hline
Windows 8        & 6.2     \\ \hline
Windows 7        & 6.1     \\ \hline
Windows Vista    & 6.0     \\ \hline
\end{tabular}
\end{table}

This operating system version directly corresponds to the Windows SDK version, i.e., for Windows 10 Professional, the latest SDK is the Windows 10 SDK used in this project. Each Windows SDK has a list of supported operating systems, and for this project, the Windows 10 SDK support goes as far as supporting Windows 7 Service Pack 1.\cite{Win10SDK}


\subsection*{Microsoft Visual Studio}
\label{ch2vs19}
The Visual Studio integrated development environment (IDE) is a feature-rich program developed by Microsoft, nearly perfect for Windows Desktop development. It includes an above standard code editor, powerful debugging tools, theme customizations, support for third-party addons, a graphic editor (Useful for designing the MFC dialog user interface, see Section \todo{reflection}), and much more.\cite{VStudio}

Visual Studio is available in three different editions: Community, Professional, Enterprise. For students, Visual Studio 2019 Community (VS19) is the best option because it is free to use under Individual Licence, which allows an individual to work and develop their own applications, whether to sell or for any other purpose.\cite{VS19TOS}

In Visual Studio, projects which work together are grouped under a \textit{Solution}. A solution can contain a single project or more. Each can be built for different operating systems, with different build tools, and with different project properties.

\subsection*{Microsoft Visual C++}
\label{ch2msvc}
The Microsoft Visual C++ Toolset (MSVC), also known as the build tools, are included in Visual Studio and contain the MSVC compiler, linker, standard libraries, and headers for Windows API development. It is usually best practice to develop under the latest version of build tools. One can invoke the MSVC compiler to compile simple programs through the command line\footnote{Windows Command Prompt}, but for most cases, it is preferred to let the IDE build programs while changing the options or flags, if needed, in the project's properties.\cite{MsVc}


\section{Windows API}
The Windows API, also often mentioned as \textit{Win32 API}, is a massive and complex collection of headers and libraries programmed in C, containing many different macros, enums, function prototypes and can be confusing to understand at first. This section aims to give a brief overview of what is important to know about Windows API before implementing an application.

\subsection*{Integer Types}
\label{winIntegers}
Integer data types are always capitalized. A standard signed integer is \lstinline{INT}, and its size is architecture-specific. To specify how long an integer is, i.e., needing a 32-bit integer in a 64-bit architecture, it is good practice to use \lstinline{INT32}. For unsigned integers, a \textit{U} prefix is used, i.e., \lstinline{UINT32}.

By standard, a Windows Word is a 16-bit unsigned short, and its data type is \lstinline{WORD}. A Double-Word is twice as long, 32-bit unsigned integer,  \lstinline{DWORD}. For historical reasons, Windows Word will always be guaranteed to be 16-bits long. To support the new 64-bit architecture, a Quad-Word, \lstinline{QWORD} is available.

\subsection*{Pointer types}
Pointer data types are defined in the form of \textit{Pointer to X}. This is often seen directly in code or Windows API function prototypes as \textit{P} or \textit{LP} prefixes on data types. \textit{P} stands for \textit{Pointer}. \textit{LP} stands for \textit{Long Pointer}, a historical holdover, and for all intents and purposes, it can be considered just a regular \textit{Pointer}. Using the standard star symbol, \textit{*}, is still a valid way to signify a pointer type while programming Windows applications.

\begin{lstlisting}[caption={An example of declaring a pointer to a double-word}]
//Each of these lines is equal
LPDWORD pdwCount;
PDWORD pdwCount;
DWORD* pdwCount;
\end{lstlisting}

\subsection*{Code conventions}
Windows uses \textit{Hungarian Notation}\footnote{\url{https://web.mst.edu/~cpp/common/hungarian.html}}, which adds semantical information to variable names in the form of prefixes. The information is supposed to let the programmer know the variable's intended use, data type, scope, etc., by just knowing its name without cross-referencing it. This is most often seen in Word and Double-Word variables having \lstinline{w} and \lstinline{dw} prefixes respectably or handles having an \lstinline{h} prefix and some pointers having a \lstinline{p} prefix.\cite{WinConventions}

\begin{lstlisting}[caption={An example of hungarian notation}]
PDWORD pdwCount; //Pointer to a double-word variable
LPWSTR lpszName; //Pointer to a zero-terminated string
LPVOID lpBuffer; //Pointer to a buffer
HINTERNET hInternet; //A handle
LPDWORD lpcbInfo; //Pointer to a count of bytes
\end{lstlisting}

Similarly, many functions expect a range of values, inputs in their calling parameters. These inputs' semantics are not always recognizable just by looking at the variable's data type. It is often generic, meaning it holds little to no information about what exactly does the function expects its input to be.
\begin{lstlisting}[caption={GetSystemMetrics prototype},label=lstGSM]
int WINAPI GetSystemMetrics(int nIndex);
\end{lstlisting}
The listing \ref{lstGSM}shows an example of an unclear expected input value \lstinline{nIndex}.\cite{WinGetSM}

\subsection*{Character set}
Functions, which manipulate characters are generally implemented in one of the following ways:
\begin{itemize}
    \item ANSI\footnote{American National Standards Institute codes \url{https://www.ansi.org/}} version, signified with the suffix \textit{A}, i.e., \lstinline{InternetOpenA}
    \item Unicode version, signified with the suffix \textit{W}, i.e., \lstinline{InternetOpenW}
    \item An adaptive, generic version, with no suffix, i.e., \lstinline{InternetOpen}. It is not implemented per se, rather defined as a macro, referring either to the ANSI or Unicode version, depending on the character set.
\end{itemize}
Some newer functions do not support ANSI and only have the Unicode version available.\cite{WinUnicode}

\subsection*{Strings}
Strings usage ties closely to the current project's character set, either defined by a macro or set up in project settings (\ref{ch2vs19}). To take advantage of the Unicode character set when possible and fall back to ANSI, when it is not, it is a good practice to know about and use \textit{portable run-time} functions and prototypes. Both prototypes and functions provide the programmer with a way to work with strings and adapt to the preferred character set automatically, recognizable by the \lstinline{T}, \lstinline{_T}, or \lstinline{_tcs} prefixes.

\begin{lstlisting}[caption={An example of defining static strings}]
char* str = "C String";
WCHAR* str = L"Wide string";
//_T is an alias of _TEXT macro
TCHAR* str = _T("Portable String");
\end{lstlisting}
As such, the \lstinline{_tcs} family of functions substitutes one-to-one with \lstinline{wcs} and \lstinline{str} family of functions. i.e., using \lstinline{_tcslen} substitutes \lstinline{wcslen} for Unicode character set and \lstinline{strlen} for ANSI character set.\cite{WinUnicodeSummary}

\subsection*{Windows}
\label{ch2Windows}
A window is a programming construct which:
\begin{itemize}
    \item Occupies a certain portion of the screen
    \item May or may not be visible at a given moment
    \item Knows how to draw itself
    \item Responds to events from the user or the operating system
\end{itemize}

By this definition, a \textit{window} in Windows programming might not always refer to the \textit{application window}. A button, text field, check box, or even a combo box is a window in itself. The difference is that the application window, also referred to as the \textit{main window}, is not part of any other window of the application. The main window also often has a title bar, a minimize button, a maximize button, and other standard UI elements.

A window can have relationships with other windows.\cite{WinWindow}
\begin{figure}[htbp]
	\centering
	%\includesvg[width=\columnwidth]{obrazky-figures/windows_example.svg}
	\caption{Example of relations between windows \todo{fix}.}
	\label{windowsExample}
\end{figure}

\subsection*{Object handles}
\label{ch2handle}
In Windows, there is no direct access to system resources like files, threads, windows, or graphic images like icons. These system resources are called objects and are unrelated to the C++ object-oriented implementation of objects. For an application to be able to access an object, it needs to obtain an object \textit{handle}.

A \textit{handle} is an opaque data type to access a system resource via the usage of related Windows API functions, which require an object's handle to identify the said object. The value has no real meaning outside of Windows operating system. One can imagine it as an entry of an internal Windows object table. An application can obtain a handle through various Windows API functions, depending on the object the application is trying to access, i.e., using the \lstinline{CreateFile}\footnote{\url{https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew}} function to access a file, which returns a handle on success.\cite{HandlesAndObjects}

Handles are kept and managed internally. Depending on the object, a single object can have either multiple handles or be limited to a single handle at a time with exclusive access.\cite{WinHandleLimits}

\subsection*{Function results}
For functions, which return handles, it is easy to tell whether or not the function succeeded at its job. Check whether or not the returned handle is invalid. On the other side, a bunch of lower-level Windows API functions returns \textit{NTSTATUS} as a result.

NTSTATUS is a 32-bit unsigned integer value, which is the result error code of an operation, i.e., a Windows API call. This means that, in general, the value of zero means success, and anything above zero is an error code, holding information about what operation failed. This has an exception, where the values \lstinline{0 - 0x3FFFFFFF} define the success status type, and values 
\lstinline{0x40000000 - 0x7FFFFFFF} define an information status type. This is easily checked with the \lstinline{NT_SUCCESS(x)} macro, where \lstinline{x} is NTSTATUS.\cite{WinNTSTATUS}\cite{WinNTSuccess}

\subsection*{Registry}
The Windows registry is a hierarchical database containing data critical for the Windows operating system's operation, services, and applications that run on it. Data is structure is essentially in a tree format, where the nodes are called \textit{keys}. A key can contain other keys - \textit{subkeys} and entires of data - \textit{values}. 

Registry values have a name, type, and value. Value types are mostly standard Windows types (\ref{winIntegers}) like a double-word, a zero-terminated string, or a generic binary value. There are several predefined (root) keys, each serving a different purpose either for the operating system itself, services, applications, or classes. The root keys are always open and are noted by the \lstinline{HKEY_} prefix.

\begin{figure}[htb!]
	\centering
	\includegraphics[]{obrazky-figures/regedit.pdf}
	\caption{Browsing Windows registry using the Registry Editor.}
	\label{winRegedit}
\end{figure}

To access a value of a key, one must know its path. The path is a string consisting of all the keys and subkeys, ranging from the root to the leaf key, divided by the backslash character.\cite{WinRegStruct}
For example, in Figure \ref{winRegedit}, to access a value inside the \lstinline{Environment} subkey, the path would be \lstinline{HKEY_CURRENT_USER\\Environment}. The Windows API provides macros for root key specification, which would allow the programmer to emit the specified root key from the path.

For an application, the registry can save user preferences, various settings, remember selected options, or track the application's usage. It is also useful to make the application run automatically upon startup, as implemented in section \todo{autorun}.

\subsection*{Thread synchronization}
There are many ways to synchronize threads in Windows. These include, but are not limited to: Events, Semaphores, Mutexes, Interlocked API, and Slim reader/writer locks (SRW Locks). As this project makes use of SRW Locks, This subsection will explain only those in this subsection.\cite{WinSyncFuncs}

An SRW Lock is a simplified version of a semaphore, a synchronization object which is useful in controlling a shared resource between multiple threads. A semaphore has a set number of threads that are allowed to access the resource simultaneously. When a thread is done with using the resource, another thread is allowed to use it.\cite{WinSemaphores} An SRW Lock takes the thread's intent with the shared resource into account and is optimized for speed and performance. If a thread wants to read a resource, it can lock the resource in a \textit{shared mode}. If a thread wants to write to a resource, it can lock the resource in an \textit{exclusive mode}. If a resource is not locked, it can be locked in either mode. 

The exclusive mode works just like a semaphore with a single allowed thread. The access is always exclusive as no other threads can access the resource simultaneously, even if some of them will just read the resource.
The shared mode allows for read-only access to the resource by multiple threads if the lock is not locked in exclusive mode.

No mode has a priority of acquiring the lock, there is no order or a queue of access, so if two threads want to lock a lock, it is not predictable which thread will acquire the lock in different modes. An SRW Lock is the size of a pointer, which means faster access and a limited amount of information stored about the lock. It is a good, simple choice for an attempt to solve \textit{"The Readers-Writers Problem}\footnote{\url{https://www.u-aizu.ac.jp/~yliu/teaching/os/lec07.html}}.
\cite{WinSRW}

\section{Microsoft Foundation Class Library}
This section introduces the Microsoft Foundation Class Library (MFC) and aims to provide an overview of important designing functions, implementing the user interfaces.

MFC is a wide-ranged object-oriented C++ library, which abstracts and wraps much of the non-object-oriented Windows API. It is useful for designing and creating user interfaces, small or large dialog boxes, windows, implementing network services, network communication, threading, and more.\cite{MFCDesktop}

\subsection*{Relations to Windows API}
As mentioned in previous sections, MFC allows for much easier desktop application development by abstracting and wrapping a lot of the Windows API, originally only written in C, into the object-oriented C++ programming language.

\begin{lstlisting}[caption={Showing a window using Windows API and MFC}, label=showWindowEx]
//Windows API - Using C
HWND hMainWnd = CreateWindowW(...);
ShowWindow(hMainWnd, SW_SHOWNORMAL);

//MFC - Using C++
AfxGetMainWnd()->ShowWindow(SW_SHOWNORMAL);
\end{lstlisting}

Listing \ref{showWindowEx} showcases an example of showing the main window (\ref{ch2Windows}) using both APIs and an instance of abstracting the window handle away in favor of using a window C++ object. Calling the \lstinline{ShowWindow}\footnote{\url{https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow}} function directly from a window object is a lot more straightforward than using handles. However, it is important to keep in mind that MFC still internally uses the Windows API.
This means, if there is a need for a handle of an MFC object, there are supportive functions like \lstinline{GetSafeHwnd}\footnote{\url{https://docs.microsoft.com/en-us/cpp/mfc/reference/cwnd-class?view=msvc-160##getsafehwnd}}, which return the internal object handle.

\subsection*{Coding conventions}
In MFC, all global static functions are marked with an \lstinline{Afx}, prefix (Application Framework Extension).

\subsection*{Wrappers}

\subsection*{Strings}

\subsection*{Exception handling}



%=============================================================================================================================
\chapter{Virtual File System technologies}
\label{ch3}
This chapter serves as an overview of available virtual filesystem technologies that would allow for direct integration with the Windows desktop environment. Such an instance of virtual filesystem implementation is, according to the Linux kernel\footnote{\url{https://kernel.org}} a "Filesystem in userspace" (FUSE), a filesystem in which an ordinary userspace process provides data and metadata.\cite{FUSE}
This exact implementation does not exist on Windows without a kernel-mode driver\cite{WinKernelFS}. Since creating a kernel-mode driver is out of this thesis's scope, the details of how this can be implemented using third-party APIs are shown in section \ref{vfsapitypes}.
The following sections contain the introduction to files, filesystems, and an overview of available third-party APIs that can be considered a valid virtual file system API option for Windows for this project's intent.

\section{Introduction to filesystems}
The following section helps to understand what a file system is, which operations are the file system's responsibility, how it talks to the file system, how it is defined on a typical file system.

\subsection*{File}
\label{file}
Generally, in Windows, a \textit{file} is a unit of data in a filesystem. A file is stored on a storage device\footnote{i.e. Hard Drive} and consists of one or multiple streams of bytes, which hold related data, and a set of attributes that describe the file and its data. The filesystem manages it, and any application that wants to access, read, write, or execute a file or its attributes has to interact with its respectable filesystem to do so. A file must follow the filesystems' rules, i.e., a file must have a unique name in its directory in NTFS\footnote{New Technology File System}.\cite{FilesAndClusters}

Files in Windows are never accessed directly. Instead, applications on Windows can access a file through its handle (Section \ref{ch2handle}). When a file is opened, a handle is associated with it until the requesting process terminates or the handle is closed. Each handle is unique to each process that opens a file, and depending on which type of access to the file was requested, if one process holds a handle to a file, a second process trying to open a handle to the same file might fail.\cite{FileHandles}

\subsection*{Filesystem}
A filesystem is a process that describes where and how files are stored on a storage device. It allows applications running on the system to access, read and store files. All Windows supported file systems have the following storage components:\cite{LocalFileSystems}

\begin{itemize}
    \item \textbf{Volumes}
    \item \textbf{Directories}
    \item \textbf{Files}
\end{itemize}

A Volume is a place where the filesystem resides, is the highest level of organization in a filesystem, and has at least one partition\footnote{Logical division of a physical disk}.\cite{WinVolumeMgmt} For this project's purposes, only volumes with a single partition (simple volumes) will be considered. Such volume can, for simplicity, be called a \textit{drive} and is recognizable and accessible by its \textit{drive letter}. 
A drive letter is a single capitalized letter of the alphabet ranging from A to Z, meaning Windows only supports a maximum of 26 drives with drive letters at the same time. The process of assigning a volume to a drive letter is referred to as \textit{mounting} the volume.

A directory is a hierarchical collection of files, can itself be organized into a directory, and has no limitations on the number or capacity of files that it contains. The only limit is defined by the filesystem itself and the capacity of the storage device.\cite{WinDirectoryMgmt} For the Windows API's intents, a directory can be referred to as a file with a special attribute.

A file (\ref{file}) is the related data, and it can be organized into a directory or reside directly in the root of a volume.

\subsection*{File path formats}
Windows uses the standard, traditional DOS\footnote{Disk Operating System} path format, which consists of the following components:

\begin{itemize}
    \item A volume or drive letter followed by the volume separator (\textbf{:}).
    \item A directory name. The directory separator character\footnote{Traditionally the backslash character (\textbackslash{})} separates subdirectories within the nested directory hierarchy.
    \item An optional filename. The directory separator character separates the file path and the filename.
\end{itemize}

If all three components are present, the path is \textit{absolute}. If no volume is specified and the path begins with the directory separator character, the path is relative from the current drive's root. Otherwise, it is relative to the current directory.\cite{WinPathFormats}

\begin{table}[!hbt]
\centering
\caption{Examples of valid file paths}
\label{filepathsex}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Path} & \textbf{Description} \\ \hline
C:\textbackslash{}dir\textbackslash{}test.pdf       & Absolute path from the root of drive \textit{C}    \\ \hline
\textbackslash{}dir\textbackslash{}test.pdf      & Relative path from the root of current drive     \\ \hline
test.pdf       & Relative path from the current directory     \\ \hline
\end{tabular}
\end{table}

\section{Virtual Filesystems}
\label{vfs}
A virtual filesystem is an abstraction of a regular file system - any information, any data, can be organized and presented as a file system. It does not require a storage device to reside on, as it can use one of the existing ones and reside and extend upon it. It can set its own rules on volume, directory, and file management and enforce them. The power of a virtual filesystem also comes with the integration to the Windows operating system - hooking into the system's internal file operations and handling them in its own way.

To achieve this, this project uses a third-party virtual filesystem API. In general, such an API usually allows to creation of a virtual filesystem by providing the programmer with a list of file operation functions that he must implement. These usually consist of functions that handle creating files, deleting files, reading files, etc. Once these functions are implemented, the user-mode library used to implement them provides them to the kernel-mode driver, allowing this new filesystem to be recognized by Windows. The process of calling implemented file operations works in reverse order. For example, when opening a file, the Windows I/O\footnote{Input\textbackslash{}Output} subsystem, which runs in kernel-mode, forwards this information to the filesystem driver, which can then invoke user-implemented functions request and handle the file operation (open the file).\cite{GitDokany}

This means that a virtual filesystem has to implement all the Windows operating system's important file operations to be functional.

\subsection*{API Types}
\label{vfsapitypes}
In general, there two types of ways a virtual filesystem API can implement a filesystem:

\begin{itemize}
    \item Native API
    \item FUSE Compatibile API
\end{itemize}

A \textit{Native API} aims to be as close to the intended system it interfaces with as possible, without potentially hurtful compromises at the cost of cross-compatibility or other factors unrelated to the system. This type can potentially be lower-level than FUSE API and must be well documented by its provider to be usable. It has only a single use and focus to work on the intended system as seamlessly as possible.

The \textit{FUSE Compatible API} is a high-level API, which is well understood from the FUSE project, originally for Linux by \textit{Miklos Szeredi}.\cite{WinFspVSFUSE}\cite{FUSE}

\subsection*{Dokany}
\cite{GitDokany}

\subsection*{VFSForGit}
\cite{GitVfsForGit}

\subsection*{WinFsp}
\cite{GitWinFsp}

%=============================================================================================================================
\chapter{Analysis}
\label{ch4}
%=============================================================================================================================
This chapter will tackle the first step of creating an application, the analysis of received requirements. In this project, the requirements are a non-formal description of the server's REST API the client is supposed to be accessing.
%=============================================================================================================================
\chapter{Design}
\label{ch5}
%=============================================================================================================================

%=============================================================================================================================
\chapter{Implementation}
\label{ch6}
%=============================================================================================================================

%=============================================================================================================================
\chapter{Testing and verification}
\label{ch7}
%=============================================================================================================================

%=============================================================================================================================
\chapter{Conclusion}
\label{ch8}
\todo{Evaluation of progress etc.}

The result application was released, and I published the source code as open-source on GitHub\footnote{\url{https://github.com/}}.

%=============================================================================================================================
 