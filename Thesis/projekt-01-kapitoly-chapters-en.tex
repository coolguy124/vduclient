\lstset{
frame=single,
language = {C++},
tabsize = 4,
captionpos=b,
showstringspaces=false,
numbers=left,
keywordstyle = \color{blue},
keywordstyle=[2]\color{gray},
stringstyle = \color[rgb]{0.64,0.08,0.08},
commentstyle = \color[rgb]{0,0.5,0},
numberstyle=\sffamily\tiny,
morecomment=[l]{\#}
%morekeywords={WORD, DWORD, PWORD, PDWORD, LPWORD, LPDWORD, QWORD, PQWORD,
%INT, INT32, INT64, UINT, UINT32, UINT64, LONG, LONGLONG, SHORT,},
}

%==============================================================================================================================
\chapter{Introduction}
\label{ch1}

Nowadays, many services allow their users to have their essential documents saved and safely backed up somewhere in the \textit{cloud}. Be it photos, videos, or just some notes kept in a Word\footnote{\url{https://www.microsoft.com/en-ww/microsoft-365/word}} document, today's technology allows anyone to access their files from any device. For example, imagine a typical browser-based could service. All that is required is for the user to have an internet connection and login, prove their identity to the \textit{server}, and the application on the user's device, the \textit{client}, takes care of the rest. After successful authentication, the user's files are available to read, download, and upload. Manually, these actions can become quite a bit of an overhead as the file count increases. What if the number of users that have access increases as well? 

The answer is - controlled access to remote documents and version control, which should be present on the server's side. In this thesis's case, the basis is an internal, non-formal API description of such a server, which will be referred to as The Validated Data Storage project (VDU). As such, this thesis analyzes previously mentioned requirements of the API access and creates a client-side application for Microsoft Widnows\footnote{\url{https://www.microsoft.com/en-us/windows}} from the ground up. To allow for a better user experience, this thesis showcases an implementation of a virtual file system, present on a virtual disk, integrated right into the desktop environment of Windows. This type of integration means being able to seamlessly view and or modify a file stored in the cloud, as if it was present on a virtual disk, without the need to download or upload after each modification constantly manually. 

WinFsp\cite{WinFsp} allows for implementing a file system in the userspace for Windows and offers both lower and higher-level APIs to work with. As such, the implementation of the VDU client-side application (VDU Client) is programmed with C++. \todo{CONTINUE later}

\section{Structure}
\todo{Add structure}

%==============================================================================================================================
\chapter{Development for Microsoft Windows}
\label{ch2}

Microsoft Windows is the most used desktop operating system on the market, consistently having more than a 70\% market share among operating systems across many years\cite{DesktopOSStats}. Windows has been in development for a few decades now, and there are many ways to create applications for it. Since creating virtual file systems is not an easy task, covered in Chapter \ref{ch3}, this thesis uses the lower-level APIs of Windows. 
This chapter introduces application development for Windows using the Windows API(also known as the Win32 API), the Microsoft Foundation Class Library, and provides an overview of these technologies. The information is relevant to implement the application in Chapter \ref{ch_implementation}.

\section{Development Environment}
This section focuses on all the preliminaries related to setting up a development environment for Windows desktop development.

\subsection{Microsoft Windows Software Development Kit}
The Microsoft Windows Software Development Kit (Windows SDK) is a required tool kit to develop and build applications for Windows. The Windows SDK contains all the libraries, headers, and tools required to design, implement, run, debug, and release Windows applications.

\subsection{Operating System Version}
The operating system version, also referred to as the build number of Windows, is the application's target version, and it does not always match the operating system's name. Deciding which version to target is important because of the application's backward compatibility between operating systems.\cite{OsVersion} 

\begin{table}[hbt]
\centering
\label{osversions}
\begin{tabular}{|l|c|l|l|}
\hline
Operating System & Version \\ \hline
Windows 10       & 10.0    \\ \hline
Windows 8.1      & 6.3     \\ \hline
Windows 8        & 6.2     \\ \hline
Windows 7        & 6.1     \\ \hline
Windows Vista    & 6.0     \\ \hline
\end{tabular}
\caption{Example table of versions of Windows desktop operating systems}
\end{table}

This operating system version directly corresponds to the required Windows SDK version for developing applications, i.e., for Windows 10 Professional, the latest SDK is the Windows 10 SDK. It is used in this project's implementation in chapter \ref{ch_implementation}. Each SDK has a list of supported operating systems. The Windows 10 SDK support goes as far as supporting Windows 7 Service Pack 1, so in theory, an application built with this SDK should run under Windows 7.\cite{Win10SDK}


\subsection{Microsoft Visual Studio}
\label{ch2vs19}
The Visual Studio integrated development environment (IDE) is a program developed by Microsoft and is nearly perfect for Windows Desktop application development. It includes a code editor with state-of-the-art IntelliSense, powerful debugging tools, theme customizations, support for third-party add-ons, and even a graphic editor (Useful for designing user interface in the form of a dialog window in section \ref{dialogdesign}).\cite{VStudio}

Visual Studio is available in three different editions: Community, Professional, Enterprise. For students, Visual Studio 2019 Community (VS19) is the best option because it is free to use under Individual Licence, allowing anyone to work and develop their own application.\cite{VS19TOS}

In Visual Studio, projects which work together are grouped under a \textit{Solution}. A solution can contain a single project or more. Each can be built for different operating systems, with different build tools, and with different project properties.

\subsection{Microsoft Visual C++}
\label{ch2msvc}
The Microsoft Visual C++ Toolset (MSVC), also known as the build tools, are included in Visual Studio and contain the MSVC compiler, linker, standard libraries, and headers for Windows API development. It is usually best practice to develop under the latest version of build tools. One can invoke the MSVC compiler to compile simple programs through the command line\footnote{Windows Command Prompt}, but for most cases, it is preferred to let the IDE build programs while changing the options or flags, if needed, in the project's properties.\cite{MsVc}


\section{Windows API}
The Windows API, also often mentioned as \textit{Win32 API}, is a massive and complex collection of headers and libraries programmed in C, containing many different macros, enums, function prototypes and can be confusing to understand at first. This section aims to give a brief overview of what is important to know about Windows API before implementing an application.

\subsection{Integer Types}
\label{winIntegers}
Integer data types are always capitalized. A standard signed integer is \lstinline{INT}, and its size is architecture-specific. To specify how long an integer is, i.e., needing a 32-bit integer in a 64-bit architecture, it is good practice to use \lstinline{INT32}. For unsigned integers, a \textit{U} prefix is used, i.e., \lstinline{UINT32}.

By standard, a Windows Word is a 16-bit unsigned short, and its data type is \lstinline{WORD}. A Double-Word is twice as long, 32-bit unsigned integer,  \lstinline{DWORD}. For historical reasons, Windows Word will always be guaranteed to be 16-bits long. To support the new 64-bit architecture, a Quad-Word, \lstinline{QWORD} is available.

\subsection{Pointer types}
Pointer data types are defined in the form of \textit{Pointer to X}. This is often seen directly in code or Windows API function prototypes as \textit{P} or \textit{LP} prefixes on data types. \textit{P} stands for \textit{Pointer}. \textit{LP} stands for \textit{Long Pointer}, a historical holdover, and for all intents and purposes, it can be considered just a regular \textit{Pointer}. Using the standard star symbol, \textit{*}, is still a valid way to signify a pointer type while programming Windows applications.

\begin{lstlisting}[caption={An example of declaring a pointer to a double-word}]
//Each of these lines is equal
LPDWORD pdwCount;
PDWORD pdwCount;
DWORD* pdwCount;
\end{lstlisting}

\subsection{Code conventions}
Windows uses \textit{Hungarian Notation}\footnote{\url{https://web.mst.edu/~cpp/common/hungarian.html}}, which adds semantical information to variable names in the form of prefixes. The information is supposed to let the programmer know the variable's intended use, data type, scope, etc., by just knowing its name without cross-referencing it. This is most often seen in Word and Double-Word variables having \lstinline{w} and \lstinline{dw} prefixes respectably or handles having an \lstinline{h} prefix and some pointers having a \lstinline{p} prefix.\cite{WinConventions}

\begin{lstlisting}[caption={An example of hungarian notation}]
PDWORD pdwCount; //Pointer to a double-word variable
LPWSTR lpszName; //Pointer to a zero-terminated string
LPVOID lpBuffer; //Pointer to a buffer
HINTERNET hInternet; //A handle
LPDWORD lpcbInfo; //Pointer to a count of bytes
\end{lstlisting}

Similarly, many functions expect a range of values, referred to as inputs, in their calling parameters. These inputs' semantics are not always recognizable just by looking at the variable's data type. It is often generic, meaning it holds little to no information about what exactly does the function expects its input to be.
\begin{lstlisting}[caption={GetSystemMetrics prototype},label=lstGSM]
int WINAPI GetSystemMetrics(int nIndex);
\end{lstlisting}
Listing \ref{lstGSM} shows an example of an unclear expected input value \lstinline{nIndex}.\cite{WinGetSM}

\subsection{Character set}
Functions, which manipulate characters are generally implemented in one of the following ways:
\begin{itemize}
    \item ANSI\footnote{American National Standards Institute codes \url{https://www.ansi.org/}} version, signified with the suffix \textit{A}, i.e., \lstinline{InternetOpenA}
    \item Unicode version, signified with the suffix \textit{W}, i.e., \lstinline{InternetOpenW}
    \item An adaptive, generic version, with no suffix, i.e., \lstinline{InternetOpen}. It is not implemented per se, rather defined as a macro, referring either to the ANSI or Unicode version, depending on the character set.
\end{itemize}
Some newer functions do not support ANSI and only have the Unicode version available.\cite{WinUnicode}

\subsection{Strings}
Strings usage ties closely to the current project's character set, either defined by a macro or set up in project settings (\ref{ch2vs19}). To take advantage of the Unicode character set when possible and fall back to ANSI, when it is not, it is a good practice to know about and use \textit{portable run-time} functions and prototypes. Both prototypes and functions provide the programmer with a way to work with strings and adapt to the preferred character set automatically, recognizable by the \lstinline{T}, \lstinline{_T}, or \lstinline{_tcs} prefixes.

\begin{lstlisting}[caption={An example of defining static strings}]
char* str = "C String";
WCHAR* str = L"Wide string";
//_T is an alias of _TEXT macro
TCHAR* str = _T("Portable String");
\end{lstlisting}
As such, the \lstinline{_tcs} family of functions substitutes one-to-one with \lstinline{wcs} and \lstinline{str} family of functions. i.e., using \lstinline{_tcslen} substitutes \lstinline{wcslen} for Unicode character set and \lstinline{strlen} for ANSI character set.\cite{WinUnicodeSummary}

\subsection{Windows}
\label{ch2Windows}
A window is a programming construct which:
\begin{itemize}
    \item Occupies a certain portion of the screen
    \item May or may not be visible at a given moment
    \item Knows how to draw itself
    \item Responds to events from the user or the operating system
\end{itemize}

By this definition, a \textit{window} in Windows programming might not always refer to the \textit{application window}. A button, text field, check box, or even a combo box is a window in itself. The difference is that the application window, also referred to as the \textit{main window}, is not part of any other window of the application. The main window also often has a title bar, a minimize button, a maximize button, and other standard UI elements.

A window can have relationships with other windows. If another window creates a window, the relationship between them is \textit{an owner/owned} relationship. If a window resides inside another window, it is called a child window. The relationship between them is \textit{parent/child}.\cite{WinWindow}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\columnwidth]{obrazky-figures/windows_rels.pdf}
	\caption{Example of owner/owned and parent/child relationships between windows.}
	\label{windowsExample}
\end{figure}

\subsection{Object handles}
\label{ch2handle}
In Windows, there is no direct access to system resources like files, threads, windows, or graphic images like icons. These system resources are called objects and are unrelated to the C++ object-oriented implementation of objects. For an application to be able to access an object, it needs to obtain an object \textit{handle}.

A \textit{handle} is an opaque data type to access a system resource via the usage of related Windows API functions, which require an object's handle to identify the said object. The value has no real meaning outside of Windows operating system. One can imagine it as an entry of an internal Windows object table. An application can obtain a handle through various Windows API functions, depending on the object the application is trying to access, i.e., using the \lstinline{CreateFile}\footnote{\url{https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew}} function to access a file, which returns a handle on success.\cite{HandlesAndObjects}

Handles are kept and managed internally. Depending on the object, a single object can have either multiple handles or be limited to a single handle at a time with exclusive access.\cite{WinHandleLimits}

\subsection{Function results}
For functions, which return handles, it is easy to tell whether or not the function succeeded at its job. Check whether or not the returned handle is invalid. On the other side, a bunch of lower-level Windows API functions returns \textit{NTSTATUS} as a result.

NTSTATUS is a 32-bit unsigned integer value, which is the result error code of an operation, i.e., a Windows API call. This means that, in general, the value of zero means success, and anything above zero is an error code, holding information about what operation failed. This has an exception, where the values \lstinline{0 - 0x3FFFFFFF} define the success status type, and values 
\lstinline{0x40000000 - 0x7FFFFFFF} define an information status type. This is easily checked with the \lstinline{NT_SUCCESS(x)} macro, where \lstinline{x} is NTSTATUS.\cite{WinNTSTATUS}\cite{WinNTSuccess}

\subsection{Registry}
The Windows registry is a hierarchical database containing data critical for the Windows operating system's operation, services, and applications that run on it. Data is structure is essentially in a tree format, where the nodes are called \textit{keys}. A key can contain other keys - \textit{subkeys} and entires of data - \textit{values}. 

Registry values have a name, type, and value. Value types are mostly standard Windows types (\ref{winIntegers}) like a double-word, a zero-terminated string, or a generic binary value. There are several predefined (root) keys, each serving a different purpose either for the operating system itself, services, applications, or classes. The root keys are always open and are noted by the \lstinline{HKEY_} prefix.

\begin{figure}[htb!]
	\centering
	\includegraphics[]{obrazky-figures/regedit.pdf}
	\caption{Browsing Windows registry using the Registry Editor.}
	\label{winRegedit}
\end{figure}

To access a value of a key, one must know its path. The path is a string consisting of all the keys and subkeys, ranging from the root to the leaf key, divided by the backslash character.\cite{WinRegStruct}
For example, in Figure \ref{winRegedit}, to access a value inside the \lstinline{Environment} subkey, the path would be \lstinline{HKEY_CURRENT_USER\\Environment}. The Windows API provides macros for root key specification, which would allow the programmer to emit the specified root key from the path.

For an application, the registry can save user preferences, various settings, remember selected options, or track the application's usage. It is also useful to make the application run automatically upon startup, as implemented in section \todo{autorun}.

\subsection{Thread synchronization}
There are many ways to synchronize threads in Windows. These include, but are not limited to: Events, Semaphores, Mutexes, Interlocked API, and Slim reader/writer locks (SRW Locks). As this project makes use of SRW locks, this subsection will explain only those in the following.\cite{WinSyncFuncs}

An SRW lock is a simplified version of a semaphore, a synchronization object which is useful in controlling a shared resource between multiple threads. A semaphore has a set number of threads that are allowed to access the resource simultaneously. When a thread is done with using the resource, another thread is allowed to use it.\cite{WinSemaphores} An SRW lock takes the thread's intent with the shared resource into account and is optimized for speed and performance. If a thread wants to read a resource, it can lock the resource in a \textit{shared mode}. If a thread wants to write to a resource, it can lock the resource in the \textit{exclusive mode}. If a resource is not locked, it can be locked in either mode. 

The exclusive mode works just like a semaphore with a single allowed thread. The access is always exclusive as no other threads can simultaneously access the resource, even if some threads only want to read the resource.
The shared mode allows for read-only access to the resource by multiple threads if the lock is not locked in exclusive mode.

Neither mode has a priority of acquiring the lock, there is no order or a queue of access, so if two threads want to lock an SRW lock, it is not predictable which thread will acquire the lock in different modes. An SRW lock is the size of a pointer, which means faster access and a limited amount of information stored about the lock. It is a good, simple choice for a project like this and is even sufficient to solve \textit{"The Readers-Writers Problem}\footnote{\url{https://www.u-aizu.ac.jp/~yliu/teaching/os/lec07.html}}.
\cite{WinSRW}

\section{Microsoft Foundation Class Library}
This section introduces the Microsoft Foundation Class Library (MFC) and aims to provide an overview of important designing functions, implementing the user interfaces.

MFC is a wide-ranged object-oriented C++ library, which abstracts and wraps much of the non-object-oriented Windows API. It is useful for designing and creating user interfaces, small or large dialog boxes, windows, implementing network services, network communication, threading, and more.\cite{MFCDesktop}

\subsection{Relations to Windows API}
As mentioned in previous sections, MFC allows for much easier desktop application development by abstracting and wrapping a lot of the Windows API, originally only written in C, into the object-oriented C++ programming language.

\begin{lstlisting}[caption={Showing a window using Windows API and MFC}, label=showWindowEx]
//Windows API - Using C
HWND hMainWnd = CreateWindowW(...);
ShowWindow(hMainWnd, SW_SHOWNORMAL);

//MFC - Using C++
AfxGetMainWnd()->ShowWindow(SW_SHOWNORMAL);
\end{lstlisting}

Listing \ref{showWindowEx} showcases an example of showing the main window (\ref{ch2Windows}) using both APIs and an instance of abstracting the window handle away in favor of using a window C++ object. Calling the \lstinline{ShowWindow}\footnote{\url{https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow}} function directly from a window object is a lot more straightforward and convenient than handles. However, it is important to keep in mind that MFC still internally uses the Windows API.
This means, if there is a need for a handle of an MFC object, there are supportive functions like \lstinline{GetSafeHwnd}\footnote{\url{https://docs.microsoft.com/en-us/cpp/mfc/reference/cwnd-class?view=msvc-160##getsafehwnd}}, which return the internal object handle.

\subsection{Coding conventions}
In MFC, all global static functions are marked with an \lstinline{Afx}, prefix (Application Framework Extension).

\subsection{Wrappers}

\subsection{Strings}

\subsection{Exception handling}

\todo{Overview key MFC parts for this project}

%=============================================================================================================================
\chapter{Virtual File System technologies}
\label{ch3}
This chapter serves as an overview of available virtual file system technologies that would allow for direct integration with the Windows desktop environment. Such an instance of virtual file system implementation is a Filesystem in userspace (FUSE), "a file system in which an ordinary userspace process provides data and metadata."\cite{FUSE}

This exact implementation does not exist on Windows without a kernel-mode driver\cite{WinKernelFS}. Since creating a kernel-mode driver is out of this thesis's scope, the details of how this can be implemented using a third-party virtual file system software are shown in section \ref{vfsapitypes}.

The following sections contain the introduction to files, file systems, and an overview of available third-party virtual file system software that can be considered a valid option for this project's intent.

\section{Introduction to file systems}
The following section helps to understand what a file system is, which operations are the file system's responsibility, how it talks to the file system, how it is defined on a typical file system.

\subsection{File}
\label{file}
Generally, in Windows, a \textit{file} is a unit of data in a file system. A file is stored on a storage device\footnote{i.e. Hard Drive} and consists of one or multiple streams of bytes, which hold related data, and a set of attributes that describe the file and its data. The file system manages it, and any application that wants to access, read, write, or execute a file or its attributes has to interact with its respectable file system to do so. A file must follow the file systems' rules, i.e., a file must have a unique name in its directory in NTFS\footnote{New Technology File System}.\cite{FilesAndClusters}

Files in Windows are never accessed directly. Instead, applications on Windows can access a file through its handle (Section \ref{ch2handle}). When a file is opened, a handle is associated with it until the requesting process terminates or the handle is closed. Each handle is unique to each process that opens a file, and depending on which type of access to the file was requested, if one process holds a handle to a file, a second process trying to open a handle to the same file might fail.\cite{FileHandles}

\subsection{Filesystem}
A file system is a program that describes how files are stored on a storage device. It allows applications running on the system to access, read and store files. All Windows supported file systems have the following storage components:\cite{LocalFileSystems}

\begin{itemize}
    \item \textbf{Volumes}
    \item \textbf{Directories}
    \item \textbf{Files}
\end{itemize}

A Volume is where the file system resides, is the highest level of organization in a file system, and has at least one partition, a physical disk's logical division.\cite{WinVolumeMgmt} For this project's purposes, only volumes with a single partition (simple volumes) will be considered. Such volume can be called a \textit{drive} if it is recognizable and accessible by its assigned \textit{drive letter}. 
A drive letter is a single capitalized letter of the alphabet ranging from A to Z, meaning Windows only supports a maximum of 26 drives with drive letters at the same time. For simplicity, the process of assigning a volume to a drive letter while making it accessible in the system will be referred to as \textit{mounting} the volume (The system can mount volumes to directories as well).

A directory is a hierarchical collection of files, can itself be organized into a directory, and has no limitations on the number or capacity of files that it contains. The only limit is defined by the file system itself and the capacity of the storage device.\cite{WinDirectoryMgmt} It is important to remember that a directory can be referred to as a file with a special flag \lstinline{FILE_BACKUP_SEMANTICS} inside the Windows API.

A file (\ref{file}) is the related data, and it can be organized into a directory or reside directly in the root of a volume.

\subsection{File path formats}
Windows uses the standard, traditional DOS\footnote{Disk Operating System} path format, which consists of the following components:

\begin{itemize}
    \item \textit{A volume or drive letter} - It is expected to be followed by the volume separator character\footnote{The colon character (:)}
    \item \textit{A directory name} - The directory separator character\footnote{The backslash character (\textbackslash{})} separates subdirectories within the hierarchy
    \item \textit{An optional filename} - The directory separator character separates the file path and the filename
\end{itemize}

If all three components are present, the path is called an \textit{absolute} path. If no volume is specified and the path begins with the directory separator character, it is relative to the current drive's root. Otherwise, it is relative to the current directory.\cite{WinPathFormats}

\begin{table}[!hbt]
\centering
\caption{Examples of valid file paths}
\label{filepathsex}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Path} & \textbf{Description} \\ \hline
C:\textbackslash{}dir\textbackslash{}test.pdf       & Absolute path from the root of drive \textit{C}    \\ \hline
\textbackslash{}dir\textbackslash{}test.pdf      & Relative path from the root of current drive     \\ \hline
test.pdf       & Relative path from the current directory     \\ \hline
\end{tabular}
\end{table}

\section{Virtual Filesystems}
\label{vfs}
A virtual file system is an abstraction of a regular file system - any information, any data, can be organized and presented as a file system. It does not require a storage device to reside on, as it can use one of the existing ones and reside and extend upon it. It can set its own rules on volume, directory, and file management and enforce them. A virtual file system's power also comes from integrating closely with the Windows operating system - hooking into the system's internal file operations and handling them in its own way.

To achieve this, this project uses a third-party virtual file system software, which exposes a virtual file system API. In general, such an API usually allows to create a virtual file system by providing the programmer with a list of file operation functions that he must implement. These usually consist of functions that handle creating files, deleting files, reading files, etc. Once these functions are implemented, the user-mode library used to implement them provides them to the kernel-mode driver, allowing this new file system to be recognized by Windows. The process of calling implemented file operations works in reverse order. For example, when opening a file, the Windows I/O\footnote{Input\textbackslash{}Output} subsystem, which runs in kernel mode, forwards this information to the file system driver, invoking user-implemented functions request and handle the file operation (open the file).\cite{GitDokany}

This means that a virtual file system must implement all the Windows operating system's important file operations to be functional. Upon implementation, a file system can even be shown directly in the Windows Explorer and be accessible to all running programs if the virtual drive of the file system is mounted. This is usually done internally within the third-party API. The following subsection covers some of the popular options of virtual file system software.

\subsection{Virtual file system software}
\label{vfsapitypes}
In general, there two ways a virtual file system software can implement a virtual file system API:

\begin{itemize}
    \item Native API
    \item FUSE Compatibile API
\end{itemize}

A \textit{Native API} aims to be as close to the intended system it interfaces with as possible, without potentially harmful compromises at the cost of cross-platform compatibility or other factors unrelated to the system. This type can potentially be lower-level than FUSE API and must be well documented by its provider to be usable. As noted by its name, tying closely to a single system means the API focuses on working on the intended system as seamlessly as possible. For windows specifically, native API requires two components, a kernel-mode driver and a user-mode library which interacts with it.

\begin{itemize}
    \item \textit{Pros}: Good optimization, coding constructs similar to the targeted system, all features of the targeted system
    \item \textit{Cons}: Little to no cross-platform compatibility, lower-level API requires deeper knowledge of the targeted system, a steeper learning curve
\end{itemize}

The \textit{FUSE Compatible API} is meant to be compatible with FUSE, a high-level API originally only for Linux. Compatibility with FUSE allows for cross-platform compatibility with little to no changes to the virtual file system's implementation. For Windows specifically, the implementation of file systems is vastly different from Linux. The usage of a FUSE compatible API comes with its compromises, such as lower performance, or excluding some of the features only present in Windows, i.e., volume labels.\cite{WinFspVSFUSE}\cite{FUSE}

\begin{itemize}
    \item \textit{Pros}: Cross-platform compatibility, easier development with higher-level API, well-documented API
    \item \textit{Cons}: Lack of Windows-specific features, restricted by POSIX standards
\end{itemize}

For this thesis, it is much preferable to choose an API software option that includes a native API, as cross-platform compatibility is not a requirement. Thus, there is no need for any restrictions. Additionally, being able to use Windows-specific file system-related features is a step towards a better user experience. An open-source license of the software would also be preferred.

\subsection{Dokany}
Dokany is one of the oldest yet still fully functional pieces of virtual file system software. It was created in 2007, and while undergoing a switching of its developers, it is still being developed today.

\begin{itemize}
    \item \textit{Supported API types}: Native, FUSE wrapper
    \item \textit{Supported languages}: C (default), Java, Delphi, DotNet, Ruby
    \item \textit{Supported architectures}: x86, x64, ARM, ARM64
    \item \textit{Supported desktop operating systems}: Windows 7 SP1 / 8 / 8.1 / 10
    \item \textit{Open-source}: Yes
    \item \textit{Provides a driver}: Yes
\end{itemize}

In conclusion, Dokany is a well-supported, stable piece of software, nearly an ideal choice for projects that pay excessive attention to software stability and compatibility while creating a file system in various, even higher-level programming languages, rather than just the low-level C.\cite{GitDokany}\cite{DokanDevIo}

\subsection{VFSForGit}
Virtual File System for Git is software developed by Microsoft to enable Git\footnote{\url{https://git-scm.com/}} at a high level, enterprise scale. VFSForGit virtualizes a Git repository into a virtual file system. This is a form of integrating the files, which are not physically present on the user's computer, rather still being present on the Git repository while being displayed. The user can download the contents of the files on request via the application's user interface. 

\begin{itemize}
    \item \textit{Supported API types}: Native GVFS Protocol\footnote{\url{https://github.com/microsoft/VFSForGit/blob/master/Protocol.md}}
    \item \textit{Supported languages}: Git commands
    \item \textit{Supported architectures}: x64
    \item \textit{Supported desktop operating systems}: Windows 10 version 1607, or later
    \item \textit{Open-source}: Yes
    \item \textit{Provides a driver}: Yes
\end{itemize}

VFSForGit is a virtual file system software aimed towards usage with Git repositories, especially at larger scales. It doesn't provide many languages or options for architectures and only supports newer versions of Windows 10. With those restrictions in mind, it is still being supported and is a useful tool for accessing Git repositories in the Windows environment.\cite{GitVfsForGit}\cite{VfsForGitMS}

\subsection{WinFsp}
Windows File System Proxy is a performant, stable collection of software components, which allows for implementing a virtual file system using one of its supported API layers. The focus of WinFsp is on high compatibility with NTFS, the default file system of Windows. This allows for smooth integration with the Windows environment and virtual file systems, which use or extend NTFS.

\begin{itemize}
    \item \textit{Supported API types}: Native, FUSE compatibility layer
    \item \textit{Supported languages}: C, C++, DotNet
    \item \textit{Supported architectures}: x86, x64, ARM, ARM64
    \item \textit{Supported desktop operating systems}: Windows 7 and above
    \item \textit{Open-source}: Yes
    \item \textit{Provides a driver}: Yes
\end{itemize}

WinFsp is a great option for any virtual file system implementation, running only on Windows. Whether it is one of the older versions of the operating system, or the newer one, WinFsp provides continuous support and compatibility with those systems while keeping the officially supported languages of its API layers both lower and higher level, thanks to the inclusion of C++ and DotNet. It is a great choice for any project starting from scratch.\cite{GitWinFsp}

\section{Windows File System Proxy}

The third-party file system software of choice for this project is Windows File System Proxy (WinFsp). VFSforGit could not be used because of its limitations and focus on Git repositories since the VDU project does not expose any Git repositories. This is further mentioned during analysis in chapter \ref{ch_analysis}. Dokany was a great option, stable, supported, and similar with compatibility layers to WinFsp. On the other hand, WinFsp has native API support for C++, which allows for cleaner and easier to understand code, and offers much better performance and optimization than Dokany. Various file system operation tests that compare versions of WinFsp against Dokany and NTFS prove this. These charts are displayed in figures \ref{winfsp_file_tests} and \ref{winfsp_rdwr_tests}.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\columnwidth]{obrazky-figures/file_tests.pdf}
	\caption{File comparison tests of WinFsp and Dokany. Source:\cite{GitWinFsp}}
	\label{winfsp_file_tests}
\end{figure}

\begin{figure}[htb]
	\centering
	\includegraphics[width=\columnwidth]{obrazky-figures/rdwr_tests.pdf}
	\caption{Read and write comparison tests of WinFsp and Dokany. Source:\cite{GitWinFsp}}
	\label{winfsp_rdwr_tests}
\end{figure}

\newpage
\subsection{Introduction}
WinFsp is
\todo{Introduce}

%=============================================================================================================================
\chapter{Analysis}
\label{ch_analysis}
%=============================================================================================================================
This chapter will tackle the first step of creating an application, the analysis, and steps taken during an analysis of provided documentation. It will introduce required technologies to understand and handle them. Results of the analysis are present at the end of this chapter.

\todo{Include google docs pdf of requirements?}

\section{Required technologies}
In this project, the provided documentation was received as a non-formal description of the server's REST API the client is supposed to be accessing. As this documentation is written in plain text, it requires proper analysis, understanding of the underlying technologies, and formalization into a better format. This section serves as an overview of these technologies.

\subsection{Hypertext Transfer Protocol}
The Hypertext Transfer Protocol (HTTP) 

\cite{MozillaHTTP}

\subsection{Representational State Transfer API}
The Representational State Transfer (REST) represents an architectural style for distributed multimedia systems. It's a programming style for developing RESTful web services, which allows the developer to take advantage of an existing protocol, HTTP. It conforms at the very least to the most basic REST constraints, as defined by its creator \textit{Roy Thomas Fielding}:

\begin{itemize}
    \item \textit{Client-Server} - Separates the client's side and the server's side
    \item \textit{Stateless} - Each request must contain all necessary information necessary to understand the request
    \item \textit{Cache} - Requests must be labeled as cacheable or non-cacheable. Improves network efficiency if it is available
\end{itemize}

These constraints are further extended specifically to address web services:
\begin{itemize}
    \item \textit{Uniform Interface} - Increases scalability at the cost of effectivity, uses a single standardized form
    \item \textit{Layered System} - Architecture composed of hierarchical layers, each component can not access other components beyond the immediate layer with which it is interacting
    \item \textit{Code-On-Demand} - Allows client functionality to be extended by downloading and executing code in the form of applets or scripts to improve system extensibility
\end{itemize}

The key abstraction of information in REST is a \textit{resource}. A resource can be anything that can be named and might be a potential target of a request, e.g., a document, an image, a data file. Interactions, i.e., manipulating a resource, happen between two parties, as noted by the first constraint, the client and server. If a client requests an operation with a resource, it sends an HTTP request, where the HTTP method is the type of operation, and the HTTP object path is the path to the resource. After processing the request, the server can inform the client about the operation's state via the HTTP status code in the HTTP response.\cite{RestAPI}

\begin{table}[hbt]
\centering
\label{restapiex}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Path} & \textbf{Description} \\ \hline
 GET & /users & Get all users \\ \hline
 POST & /users/john & Update an user  \\ \hline
 DELETE & /users/john &  Delete an user \\ \hline
 PUT & /users & Add an user \\ \hline
\end{tabular}
\caption{Examples of REST API requests}
\end{table} 

\subsection{OpenAPI}
The OpenAPI Specification is an API description format for REST APIs. An entire API can be described with just a single file of the OpenAPI format, which supports file formats of either YAML\footnote{A recursive acronym for "YAML Ain't Markup Language"} or JSON\footnote{JavaScript Object Notation}. OpenAPI describes:

\begin{itemize}
    \item Available endpoints and operations on each endpoint
    \item Operation parameters, and input/output for each operation
    \item Authentication methods
    \item Contact information, terms of use, other information
\end{itemize}

The OpenAPI format is easily readable by both machines and humans. Many third or first-party services provide a way to visualize the API in a graphical format, i.e., the Swagger Editor\footnote{\url{https://editor.swagger.io/}}.\cite{SwaggerDocs}

\newpage
\begin{lstlisting}[caption={An example of an OpenAPI file in the YAML format}, label=openapiex]
#A simple documentation of a /ping endpoint
openapi: 3.0.0 
info:
  version: '1.0' 
  title: An amazing API
  description: A formal description
servers: #Server URL for testing
  - url: 'https://localhost:4443'
paths: #Endpoint descriptions
  /ping: #Endpoint path
    get: #Method
      parameters: [] #Call parameters
      description: To test a connection.
      responses: #Possible responses
        '204':
          description: Ping success!
\end{lstlisting}

\todo{More about openapi, like, basic structure? Probably not necessary tho.}

\section{Formalization}
Considering the provided documentation, formalization means creating an OpenAPI specification based on the documentation's plain text version. A formalized specification allows for better readability, understanding, development, and testing on the developer's side. The formalized specification's concrete usage is covered in chapter \ref{ch_implementation}, implementing the client, and \ref{ch_testing} for implementing and testing a mock server.

\subsection{Creating the specification}
Formalizing the provided documentation consists of reading and understanding all the API endpoints and their access or usage restrictions and manually creating an entry for each in an OpenAPI file. Each entry has its own possible status codes, headers, and content, which endpoint could return. For this project, I used the Swagger Editor, which allowed me to document the VDU API more comfortably. The editor's great advantage is that it can render the OpenAPI specification file in an HTML\footnote{Hyper-Text Markup Language} 5 format, as shown in Figure \ref{swagger_result}.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\columnwidth]{obrazky-figures/swagger_result.pdf}
	\caption{VDU REST OpenAPI 3.0 summary, rendered using the Swagger Editor, authentication requirement is signified by the lock icon.}
	\label{swagger_result}
\end{figure}

I analyzed and noted all the API access requirements, each method, its parameters, return values, and how they tie to each other from the formal, well-specified API documentation. Afterward, I discussed this information further with my supervisor, which allowed me to understand better how the API works and how it should interact.

\section{Results}
\label{analysis_results}
This section will summarize the result of the VDU API documentation analysis. These results are used to guide the design of the application in Chapter \ref{ch_design}.

\subsection{Endpoints}
This subsection lists all available VDU API endpoints, as shown in Figure \ref{swagger_result}, and provides an overview of their usages. Some endpoints require an \textit{X-Api-Key} (API key) for successful access.

\begin{itemize}
    \item \textit{GET} \textit{/ping} - Tests a connection to the server
    \item \textit{POST} \textit{/auth/key} - Authenticates an user by name or email. Client secret can be included in the content if necessary. Returns API key on success.
    \item \textit{GET} \textit{/auth/key} - Returns a new API key with new expiration time, refreshes session
    \item \textit{DELETE} \textit{/auth/key} - Invalidates API key
    \item \textit{GET} \textit{/file/\{file-access-token\}} - Returns file contents, additional file information is in the response headers
    \item \textit{POST} \textit{/file/\{file-access-token\}} - Uploads file contents, additional file information has to be in the request headers
    \item \textit{DELETE} \textit{/file/\{file-access-token\}} - Invalidates a file token, does NOT delete the file from VDU system
\end{itemize}

\subsection{Access}
Both client and server must use a secure TLS\footnote{Transport Layer Security} channel to access the VDU API, while the server must have a valid server-side TLS certificate. This implies the usage of HTTPS protocol to access the API. The client-side certificate is optional and allows the user to omit the client secret from the authentication endpoint.

The authentication is done using an API key, which is first obtained from the \lstinline{POST /auth/key} endpoint. An API key has its expiration date, which a client must respect, and the key has to be refreshed using the \lstinline{GET /auth/key} endpoint if it is about to expire. The client can prematurely invalidate the API key with the \lstinline{DELETE /auth/key} endpoint.

File tokens, seen as the path parameter \textit{\{file-access-token\}} in the \lstinline{/file/} endpoint, are generated from the proprietary VDU web user interface. Each token represents a single file, has an expiration date, and can be prematurely invalidated using the \lstinline{DELETE /file/} endpoint. This file can be modified using the \lstinline{POST /file/} endpoint, which includes modifying its content and file name. A file can be read-only, meaning that the server will deny any modification request.

\subsection{Version control}
The file version control system is handled on the VDU server. The VDU client does not manage or control the version of a file. This version is noted as an \lstinline{ETag} header, which can be any string. The VDU server can change this tag upon successful file upload on the server's side, which could lead to invalidation of the user's file token directly after the upload. The client has to adapt to the server-side version, which it receives via a response from the \lstinline{/file/} endpoint, and must not propose its own.


%=============================================================================================================================
\chapter{Design}
\label{ch_design}
%=============================================================================================================================
This chapter aims to design the application based on knowledge from previous chapters. The designing process consists of two main parts - the visual and the inner application design part. The visual part takes care of the user interface, user experience, all the windows, menus, buttons, and overall feeling of the application for the user. The inner application part revolves around the class structure and relationships, chooses coding practices and various internal options for designing the application, which is implemented in chapter \ref{ch_implementation}.

\section{User interface}
The user interface includes all the application's visual elements and all the other elements a user can interact with while using the application. Based on the VDU API documentation analysis of requirements, I listed all important actions and ways users could interact with the VDU client. These key functionalities can be referred to as \textit{user actions}: 

\begin{itemize}
    \item Test a connection to the server
    \item Login/out of the system
    \item Change the virtual drive letter
    \item Input a file token to access a file
    \item Read and modify accessed files, concerning version control
    \item Invalidate a file token of a file
\end{itemize}

The following subsections explain how the application's user interface was thought out, designed, and my thoughts behind those decisions.

\subsection{Integration into Windows environment}

Note that not all of these actions have to be included in the application's user interface. For example, the user can read and modify files via some other application present on the system, completely unrelated to the VDU client. This fact has lead me to an important realization. Windows Explorer, a handy tool for browsing files in Windows, has an amazing user interface that can display files provided by a file system - such as a virtual file system of the VDU client. 
Using Windows File Explorer to provide the functionality of file access-related actions is a very user-friendly, intuitive way of integrating with the Windows desktop environment.


There is one more action that the Windows File Explorer is capable of - deleting files. Note that the VDU API does not provide an endpoint for file deletion per se. Rather, an endpoint for invalidating a file token. This means, deleting files downloaded from the VDU server in the virtual file system becomes confusing to use for the user as a file would be deleted only locally, and this action would not invalidate the token. This has lead me to an unusual design decision. Re-purposing the file deletion feature to invalidate the file's token and only delete the local file if the server allows so. Thus, the number of action which the VDU client has to implement in its own user interface is reduced even more. 

In conclusion, by using built-in features of existing applications in the Windows environment, specifically the Windows File Explorer, I was able to simplify the VDU client's user interface while keeping its functionality unchanged. Details on how exactly this is implemented and why it is not limited to Windows File Explorer only are explained in chapter \ref{ch_implementation}.

\subsection{Dialog design}
\label{dialogdesign}
After narrowing down all user actions, as shown in the use case diagram in Figure \ref{usecasediagr}, the next step is to design the actual VDU client interface.

\begin{figure}[htb]
    \centering
    \includegraphics[width=\columnwidth]{obrazky-figures/usecasediagr.pdf}
	\caption{Use case diagram from the view point of an user of the VDU Client system and the Windows environment it resides in.}
	\label{usecasediagr}
\end{figure}

 Considering the low amount of functionality required, I decided to go with a simple extended dialog window design(dialog). The dialog, seen in Figure \ref{clientui}, is separated into three sections:
 \begin{itemize}
     \item \textit{Connection} - Client-Server functionality
     \item \textit{File System} - Local virtual file system functionality
     \item \textit{Status} - Information about the state of the application
 \end{itemize}
The idea behind division was to improve visual clarity while keeping the interface compact and easy to navigate.

\begin{figure}[htb]
    \centering
    \includegraphics[]{obrazky-figures/clientui.pdf}
	\caption{User interface of the VDU Client application.}
	\label{clientui}
\end{figure}

\subsubsection{Connection section}
This section contains information about the server address, user name, and, if required, a path to a client certificate (client secret) to include the login information. Connection to the server can be tested using the \textit{Ping} button. The \textit{Login} button allows the user to authenticate himself to the server and changes to a \textit{Logout} button upon successfully logging in. Logging in enables all authentication restricted functionality in the following sections and the entire application.

\subsubsection{File system section}
The \textit{Access file} button attempts to download and launch a file from the VDU server, given a token from the input field. The user is also given an option to choose a preferred drive letter for the virtual drive, which the VDU virtual file system will control.

\subsubsection{Status section}
\label{statussectionui}
Containing only a progress bar and a status text, this section informs the user about the application's state. This information includes download progress - visible on the progress bar, connection status, number of accessed files, and currently logged-in user.

\subsection{Dialog tray}
When the VDU application is running, implicitly, so is the dialog window. This is true even if a user is not using the dialog window actively. In a simple use case scenario, the dialog window is only required to log in and access a file. Afterward, it theoretically does not have to be cluttering so much space on the screen and the taskbar. 

This inspired me to design a beneficial addition to the dialog - a tray icon. This icon resides in the tray area of the Windows user interface. The idea is simple, upon closing or minimizing the dialog, the application would stay running in the background, signified by the icon being present. The user can restore the dialog window by simply clicking on the VDU Client icon, displayed in Figure \ref{iconscloud}, in the tray area.

\begin{figure}[htb]
    \centering
	\includegraphics[width=50px]{obrazky-figures/cloudicon.pdf}
	\caption{Cloud Storage Icon, used as the main icon for VDU client application, Source:\cite{Icons8Cloud}.}
	\label{iconscloud}
\end{figure}

Furthermore, removing the ability to close and exit the application from the dialog window has moved this responsibility to the tray icon. I designed a simple tray menu to fix this problem, depicted in Figure \ref{traymenuex}, which becomes active after right-clicking the icon. The \textit{Exit} option in this menu, shown in the listing, is how the user is supposed to quit using the application.

\begin{figure}[htb]
    \centering
	\includegraphics[]{obrazky-figures/traymenu.pdf}
	\caption{Tray menu of the VDU Client application.}
	\label{traymenuex}
\end{figure}

Windows allows applications that put icons in the tray area to display a small text message while hovering the icon - a \textit{tray tip}. I utilized this tray tip to display a compact, text version of the data from the status section \ref{statussectionui} of the dialog, as displayed in Figure \ref{traytipex}.

\begin{figure}[htb]
    \centering
	\includegraphics[]{obrazky-figures/traytip.pdf}
	\caption{Example of a tray tip, displaying the state of the application.}
	\label{traytipex}
\end{figure}

\subsection{Responsiveness and notifications}
A good application needs to be responsive and notify the user about important events. Every action directly taken by the user should have a visual response. Given the specifications, the VDU client application will communicate with a server over a network connection. Whether the server resides in a local network or on the internet, it is safe to assume that the application will not finish an action instantaneously. This means a good, responsive application needs to notify the user via the user interface using two types of responses:
\begin{itemize}
    \item \textit{Instant} - Direct visual response to an action, proving to the user that the application is working on the user's request
    \item \textit{Delayed} - A second, more detailed response, once enough information is gathered from the server
\end{itemize}

The application must keep being responsive while handling responses to all actions. How this is implemented is explained in section \todo{Implementation}.

For the VDU client dialog window, an instant response consists of enabling or disabling the related child windows\footnote{e.g. buttons, check-boxes, combo-boxes}. For example, an instant response to clicking the \textit{Ping} button, as displayed on the user interface in Figure \ref{clientui}, would disable the button, making it non-clickable. This button would be then enabled once again along with the follow-up - delayed response.
The delayed response consists of either creating a message box or displaying a Windows notification.

\subsubsection{Message box}
A message box in the VDU client is a simple window, often created as an \textit{owned window} relative to the main window. It is used as either an instant or a delayed response to important actions caused directly by the user, i.e., trying to test a connection to an incorrect server will result in a message box depicted in Figure \ref{messageboxex}. 

\begin{figure}[htb]
    \centering
	\includegraphics[]{obrazky-figures/messageboxex.pdf}
	\caption{A message box window, displayed after the application fails to connect to a server.}
	\label{messageboxex}
\end{figure}

\subsubsection{Windows notifications}
For less important and rather informative actions, a Windows notification shows up as a response. Such a notification, displayed in Figure \ref{notificationex}, appears, for example, after a successful download of a newly accessed file, along with an automatic startup of the assigned application to the file type. This lets the user know it was the VDU client which caused the application to open.
\begin{figure}[htb]
    \centering
	\includegraphics[]{obrazky-figures/notificationex.pdf}
	\caption{A windows notification, displayed after a successfully obtaining access to a file in the bottom right corner of the screen.}
	\label{notificationex}
\end{figure}

\section{Class structure}
Choosing the right design of the VDU client's internal components is key to creating a good, reliable, and scalable application. As depicted in the Unified Modeling Language (UML) class diagram in Figure \ref{vduclassdiagram}, the inspiration for the concrete class structure and design was the \textit{Single Responsibility Principle} (SRP).

According to \cite{CleanCodeBook}, SRP is a useful design principle to keep in mind while designing object-oriented classes or modules. This is especially useful for applications, which aim to be reliable, easy to maintain, and scalable. SRP states, for example, that a single class should only have a \textit{single reason to change}. This shifts all the responsibilities related to its purpose and allows it to be developed independently from others. Following SRP is a good way to keep software and its code clean and easy to understand. This has led me to design the following classes for the application:
\begin{itemize}
    \item \textit{VDUClient} - Main class of the application
    \item \textit{CVDUClientDlg} - Instantiates and handles the dialog window
    \item \textit{CVDUConnection} - Provides a communication layer with the server
    \item \textit{CVDUSession} - Provides a session functionality for authentication purposes
    \item \textit{CVDUFile} - Represents the structure and data of an accessed file from the VDU server
    \item \textit{CVDUFileSystem} - Implements the virtual file system
    \item \textit{CVDUFileSystemService} - Provides functionality to interact with the virtual file system
\end{itemize}
\begin{figure}[htb]
    \centering
	\includegraphics[width=\columnwidth]{obrazky-figures/vduclassdiagram.pdf}
	\caption{UML class diagram of the VDU Client application. \todo{REDO IN THE PROGRAM}}
	\label{vduclassdiagram}
\end{figure}
Each class has a name that implies its purpose and responsibility. All classes rely on each other to exist and can be instantiated for the VDU client to function, except the dialog handling class, \lstinline{CVDUClientDlg}, which is not required to be instantiated when the application's \textit{testing mode} is enabled. The testing mode is used while performing automatic tests on the application in chapter \ref{ch_testing}.

\section{Data storage}
There are many ways to go about storing data for an application. For the VDU client, there are two types of data, which need to be stored:
\begin{itemize}
    \item \textit{Files} - The actual downloaded files from the VDU server, stored using the host file system
    \item \textit{Settings} - The configuration of the application, stored using Windows registry
\end{itemize}

\subsection{Host file system}
For files, it is highly advantageous to store them using the host file system over all other options available. The VDU client stores downloaded files in a temporary folder on the main drive, using the host file system. This folder exists per user, meaning each local user of Windows has their own temporary folder tied to their Windows account. This prevents unintended file sharing if multiple users are using the application on the same system. This folder is emptied each time the application starts and has a randomly generated name upon each creation. If the system crashes, all unsaved files will stay in this folder, available for potential data recovery. \todo{Detailed temp?}

\subsubsection{Motivation}
Creating a virtual file system gives freedom to portray any data as files. This fact has inspired me to attempt to store the files using just the systems Random-Access Memory (RAM) of the application. While the speed and accessibility of RAM might make this idea seem plausible, in reality, it would not work well enough for a couple of reasons:
\begin{itemize}
    \item \textit{Space limitations} - Large files might not have enough space
    \item \textit{Inactive RAM usage} - Files not actively in use might prevent other applications from using that space
    \item \textit{No file recovery} - If the system crashes, there is no way to recover unsaved work with the files
\end{itemize}

\subsection{Windows registry}
The application's configuration does not require much space, and as such, the idea of using a custom database or storing it as a file on the host file system seems quite far-fetched. 
One can simplify an application's configuration settings into a simple pair \lstinline{key:value}, where the \textit{key} is a unique identifier of data type \textit{string}, and \textit{value} can be any supported data type on the system. The Windows registry allows applications to store information in this exact format, making it an ideal choice of data storage for the VDU client's configuration settings. The Table \ref{vduregistrytable} lists out the concrete settings stored inside the registry by the application.
\begin{table}[hbt]
\centering
\label{vduregistrytable}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{Data type} & \textbf{Description} \\ \hline
 AutoLogin & double-word & AutoLogin feature state \\ \hline
 ClientCertPath & string & Path to client secret file \\ \hline
 LastServerAddress & string & Last entered server address \\ \hline
 LastUserName & string & Last entered user name \\ \hline
 PreferredDriveLetter & string & Selected preferred drive letter \\ \hline
 UseCertToLogin & double-word & Whether or not to use client secret \\ \hline
 WorkDir & string & Current directory used to store VDU files  \\ \hline
\end{tabular}
\caption{The concrete settings stored by VDU Client using the Windows registry.}
\end{table} 



%=============================================================================================================================
\chapter{Implementation}
\label{ch_implementation}
%=============================================================================================================================
This chapter covers the exact internal implementation of key elements of the VDU client, as described in previous chapter \ref{ch_design}, which covered the overall design of application. The entire implementation of the application itself was done using Visual Studio Community 2019, an awesome IDE\footnote{Integrated Development Environment} developed by Microsoft, which was further described in section \ref{ch2vs19}. 

\section{User Interface}
The user interface was 

\section{Internal design}

\subsection{Thread synchronization}

\section{}

%=============================================================================================================================
\chapter{Testing}
\label{ch_testing}
%=============================================================================================================================
Application testing is a key development process used to assert and verify the application's correct functionality and the presence of its required properties. In the case of the VDU Client, the requirement is to enable the application to be tested using automated tests. Automating the testing of a Windows GUI\footnote{Graphical User Interface} application that appears to be entirely controlled by the user's input can prove to be challenging at first. With good knowledge of the Windows API, visualizations from analysis in chapter \ref{ch_analysis} and a scripting language, I was able to simulate a VDU server and create an expandable testing script, that made implementing and running automated tests easier and scalable.

\section{VDU server simulation}
Due to the network connection requirements of the client-server type of applications, it is difficult to provably test the functionality and properties of the client without the presence of the server. Additionally, flooding a production server with automated testing might lower the quality of service for real users. This is the motivation behind creating a simulated VDU server, which would only be present locally and be able to simulate fulfilling the requests of the client with valid responses and comes with several advantages over the real VDU server:
\begin{itemize}
    \item \textit{Independence} - Even if the VDU server stops working, testing can continue
    \item \textit{Interface stability} - A sudden change in the interface of VDU server will not affect the application
    \item \textit{Flexibility} - Application can be modified and properly tested over time to comply with any changes on the server
    \item \textit{Transfer speed} - Transferring files is limited only by the speed of the local network
\end{itemize}

\subsection{Specifications and analysis}
In this section, the formal VDU server API specifications, analyzed in chapter \ref{ch_analysis}, are an important point of reference. As this specification clearly states, the VDU server communicates over the HTTP protocol in TLS\footnote{Transport Layer Security}/HTTP channel and provides a REST API interface to interact with. Knowing this, the VDU server can be simplified down to a program, that:
\begin{itemize}
    \item \textit{Hosts an HTTP server with a secure TLS channel}
    \item \textit{Is able to read and modify files}
\end{itemize}
Alternatively, in order for the simulated server to behave just like a real VDU server, it needs to simulate every endpoint of the real VDU server. The exact implementation of either server is not relevant for this purpose.

\subsection{Design}
Given the simplistic nature of the program requirements, in order to save time while sacrificing little to no functionality, I have decided to create the simulated VDU server using Python\footnote{\url{https://www.python.org/}}.

\subsubsection{Python}
Python is an interpreted, simple, easy to learn programming language with emphasis on readability of its syntax. It is considered a high-level language, allows for object-oriented programming and dynamic typing. A program written in the Python programming language is referred to as a Python script, since it is interpreted using the Python interpreter, which comes equipped with feature-rich default libraries that are completely able to cover the requirements for a simulated VDU server, as described by \cite{PythonWhatis}. These facts make Python a great programming language choice for the implementation of the server.
\subsubsection{Simulating endpoints}
 While knowing the exact implementation of the server would make simulation more precise, for the purposes of this thesis it was unknown. Thanks to the properly detailed specification and description of each endpoint, simulating every single endpoint was still possible.
 
 \subsection{HTTPS/TLS support}
Knowing that the real server uses HTTPS protocol to communicate with the client, the simulated server had to support this as well. In order to start a 

According to \cite{SSLCertTut},
 
\subsection{Implementation}



\subsection{}

\section{Modifying the application}

\section{Unit testing}


%=============================================================================================================================
\chapter{Conclusion}
\label{ch_conclusion}
\todo{Evaluation of progress etc.}

The result application was released, and I published the source code as open-source on GitHub\footnote{\url{https://github.com/}}.

%=============================================================================================================================
